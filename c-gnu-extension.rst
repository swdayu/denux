GNU语言扩展
===========

GNU C 提供了一些在 ISO 标准 C 中不存在的语言特性。如果指定了 -pedantic 选项，GCC 会在
使用这些特性中的任何一个时打印警告消息。要测试这些特性在条件编译中的可用性，请检查预定义
的宏 __GNUC__，该宏在使用 GCC 时始终被定义。

这些扩展在 C 和 Objective-C 中可用。其中大多数在 C++ 中也可用。有关仅适用于 C++ 的扩
展，请参考 C++ 语言扩展部分。一些在 ISO C99 中存在但在 C90 或 C++ 中不存在的特性，作
为扩展，也被 GCC 扩充在 C90 模式和 C++ 中。

备用关键字
-----------

启用 -ansi 和各种 -std 选项会禁用某些关键字。如果你想要使用某些 GNU C 扩展或通用头文件
（该头文件要被所有程序使用，包括 ISO C 程序），可能会有麻烦。因为这种情况下，关键字
asm、typeof 和 inline 都不可用，除了 inline 可以在 c99 及之后的版本可用之外。另外
ISO C99 关键字 restrict 只有在使用 -std=gnu99、-std=c99 或更新标准时才可用。

解决这些问题的方法是在每个有问题的关键字的开头和结尾加上 __。例如，使用 __asm__ 代替
asm，使用 __inline__ 代替 inline。其他 C 编译器不接受这些备用关键字；如果你想用其他编
译器编译，你可以将备用关键字定义为宏，以替换为常用关键字，看起来像这样： ::

    #ifndef __GNUC__
    #define __asm__ asm
    #endif

选项 -pedantic 和其他选项会对许多 GNU C 扩展生成警告。你可以使用关键字 __extension__
来抑制这类警告。具体来说：在表达式之前写上 __extension__ 可以防止对该表达式内的扩展发
出警告；或者在早于 C23 标准的 C 代码中使用 [[__extension__ ...]] 可以抑制对使用形式
为 [[...]] 的属性的警告。__extension__ 除了上述用途外，没有其他作用。

内联汇编
---------

使用 asm 关键字允许你在 C 代码中嵌入汇编指令。GCC 提供了两种形式的内联汇编语句。基本汇
编语句没有扩展的 C 语言表达式操作数，而扩展的汇编语句包含一个或多个 C 语言表达式操作
数。在函数内混合 C 语言和汇编语言时，推荐使用扩展汇编，但如果要在顶级（即在函数外）包含
汇编语言，则必须使用基本汇编。你还可以使用 asm 关键字覆盖 C 语言符号的汇编名称，或者将
C 变量放置在特定的寄存器中。

**基本汇编**

基本汇编语句具有以下语法： ::

    asm asm-qualifiers ( AssemblerInstructions )

对于 C 语言，asm 关键字是一个 GNU 扩展。当编写能够使用 -ansi 选项和 -std 选项（选择一
个不含 GNU 扩展的 C 语言标准）进行编译的 C 语言代码时，请使用 __asm__ 代替 asm（参见
备用关键字部分）。对于 C++ 语言，asm 是一个标准关键字，但对于使用 -fno-asm 选项编译的
代码，可以使用 __asm__。

汇编限定符（qualifier）volatile：可选的 volatile 限定符没有任何作用，所有基本汇编块默
认都是 volatile 的。inline：如果你使用了 inline 限定符，那么为了内联，汇编语句的大小
总采用可能的最小大小，参见汇编语句的大小部分。

汇编语句的参数，汇编指令是一个指定汇编代码的字符串字面量。该字符串可以包含汇编器识别的任
何机器指令（instructions），包括汇编语法命令（directives）。GCC 不会解析汇编指令本
身，也不知道它们的含义，甚至不知道它们是否是有效的汇编输入。你可以将多个汇编指令放在一个
汇编字符串中，用系统汇编代码中通常用于分隔行的字符分隔。在大多数地方都适用的组合是使用一
个换行符用来分行，再加上一个制表符（写为 \n\t）。有些汇编器允许分号作为行分隔符，但是注
意有些汇编语言使用分号注释注释。

通常情况下，使用扩展汇编会产生更小、更安全、更高效的代码，在大多数情况下，它是一个比基本
汇编更好的解决方案。然而，有两种情况只能使用基本汇编：

1. 扩展的汇编语句必须在 C 函数内，因此要在顶级文件范围作用域，即在 C 函数之外编写内联汇
   编时，你必须使用基本汇编。你可以使用这种技术来生成汇编语法命令，定以在文件其他地方可
   以调用的汇编语言宏，或者使用汇编语言编写整个函数。函数外的基本汇编语句不能使用任何限
   定符。

2. 被声明为裸函数的函数也必须使用基本汇编，参见函数属性部分。

从基本汇编安全地访问 C 数据和调用函数比看起来要复杂得多。要访问 C 数据，最好使用扩展汇
编。不要期望一系列的汇编语句在编译后仍然完全连续。如果某些指令需要在输出中保持连续，将它
们集成放在包含多条指令的单个汇编语句中。注意，GCC 优化器可以相对其他代码移动汇编语句，
包括跨越跳转。汇编语句不能跳转到其他汇编语句中，GCC 不知道这些跳转，因此在决定如何优化
时无法考虑它们。跳转到 C 标签只在扩展汇编中受支持。

在某些情况下，GCC 可能在优化时对你的汇编代码进行复制（或删除重复项）。这可能会导致在编
译期间出现意外的重复符号错误，如果你的汇编代码定义了符号或标签。警告：C 标准并没有指定
asm 的语义，这使得它成为编译器之间潜在的不兼容性来源。这些不兼容性可能不会产生编译器警
告或错误。GCC 不会解析基本汇编的 AssemblerInstructions，这意味着没有办法向编译器传达
它们内部发生了什么。GCC 无法看到汇编中的符号，并且可能会将它们视为未引用的而丢弃。它也
不知道汇编代码的副作用，例如对内存或寄存器的修改。与某些编译器不同，GCC 假设不会对通用
寄存器进行更改。这一假设在未来版本中可能会改变。

为了避免未来对语义的更改带来的复杂性以及编译器之间的兼容性问题，请考虑用扩展汇编替换基本
汇编。有关如何进行此转换的信息，请参阅如何从基本汇编转换为扩展汇编
（https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended）。
编译器会将基本汇编中的汇编指令逐字复制到汇编语言输出文件中，而不会处理方言或扩展汇编中可
用的任何 % 操作符。这导致基本汇编字符串和扩展汇编模板之间存在细微差异。例如，引用寄存器
时，你可以在基本汇编中使用 %eax，而在扩展汇编中需要使用 %%eax。在支持多种汇编方言的目
标（如 x86）上，所有基本汇编块都使用由 -masm 命令行选项指定的汇编方言（默认为att语法风
格）。基本汇编没有机制为不同方言提供不同的汇编字符串。对于具有非空汇编字符串的基本汇编，
GCC 假设汇编块不会更改任何通用寄存器，但它可能会读取或写入任何全局可访问变量。
以下是一个适用于 i386 的基本汇编示例： ::

    // 注意，此代码无法与 -masm=intel 选项一起编译
    #define DebugBreak() asm("int $3")

**汇编语句的大小**

某些目标平台要求 GCC 跟踪每条指令的大小，以便生成正确的代码。由于汇编语句产生的代码的最
终长度只有汇编器才知道，GCC 必须估计它将有多大。它通过计算汇编语句中的指令数量，并将其
乘以该处理器支持的最长指令的长度来实现这一点。在计算指令数量时，它假设任何换行符或汇编器
支持的语句分隔符字符（通常是;）的出现表示一条指令的结束。

通常，GCC 的估计足以确保生成正确的代码，但如果你使用了伪指令或汇编宏，它们会扩展成多条
实际指令，或者如果你使用汇编语法指令，这些指令在目标文件中占用的空间比单条指令所需的空间
更多，那么就可能使编译器感到困惑。如果发生这种情况，汇编器可能会产生一个诊断信息，指出某
个标签无法到达。

这个大小也用于内联决策。如果你使用 asm inline 那么为了内联目的，汇编语句的大小将被视为
最小值，忽略 GCC 认为的大小。

控制汇编名称
------------

你可以使用 asm（或 __asm__）关键字来指定 C 函数或变量在汇编代码中的名称。你需要确保选
择的汇编名称不会与其他汇编符号或寄存器名称冲突。以下展示了如何为数据指定汇编名称： ::

    int foo asm ("myfoo") = 2;

它指定在汇编代码中变量 foo 的名称是 myfoo，而不是默认的 C 名称 _foo。GCC 不支持将此功
能用于非静态局部变量，因为这些变量没有汇编名称。如果你试图将变量放入特定寄存器，请参阅显
式寄存器变量部分。

要为函数指定汇编名称，需要在函数定义对函数进行声明，并加上 asm 语句，如下所示： ::

    int func (int x, int y) asm ("MYFUNC");
    int func (int x, int y)
    {
        /* . . . */
    }

这指定了在汇编代码中函数 func 的名称是 MYFUNC。

指定寄存器
----------

GNU C 允许你将特定的硬件寄存器与 C 变量关联。在几乎所有情况下，允许编译器分配寄存器会产
生最佳代码。然而，在某些不寻常的情况下，可能需要对变量存储进行更精确的控制。全局变量和局
部变量都可以与寄存器关联。执行此关联的后果在两者之间有很大不同，如下所述。

**全局寄存器变量**

你可以定义一个全局寄存器变量，并将其与指定的寄存器关联，如下所示： ::

    register int *foo asm ("r12");

这里 r12 是应该使用的寄存器名称。注意，这与定义局部寄存器变量的语法相同，但对于全局变
量，声明出现在函数外部。register 关键字是必需的，不能与 static 结合使用。寄存器名称必
须是目标平台的有效寄存器名称。不要使用类型限定符，如 const 和 volatile，因为结果可能与
预期相反。特别是，使用 volatile 限定符并不能完全防止编译器对寄存器的访问进行优化。

在大多数系统上，寄存器是一种稀缺资源，允许编译器对它们的使用进行管理通常会产生最佳代码。
然而，在特殊情况下，保留一些全局变量的寄存器是有意义的。例如，这在像编程语言解释器这样的
程序中可能会很有用，这些程序有几个经常访问的全局变量。

定义全局寄存器变量后，对于当前编译单元：

1. 如果寄存器是被调函数负责保护的寄存器，则调用 ABI 会受到影响：该寄存器变量被赋值后不
   会在函数尾声序列中恢复。因此，函数不能安全地返回给假设标准 ABI 的调用者。

2. 反之，如果寄存器是函数调用者保护的寄存器，则调用标准 ABI 函数可能会破坏变量的内容。
   即使在原始程序中没有这种调用，可能会被编译器创建，例如当使用 libgcc 函数来弥补不可
   用的指令时。

3. 对变量的访问可以像往常一样进行优化，寄存器仍然可以用于分配和计算，只要不影响变量的可
   观察值。

4. 如果在内联汇编中引用变量，则必须通过约束向编译器提供访问类型。不支持从基本汇编语句中
   对其进行访问。

注意，这些点仅当编译这些定义的代码时适用，仅链接的代码（例如来自库的代码）不受影响。如果
你想重新编译不实际使用你的全局寄存器变量的源文件，以便它们不将指定的寄存器用于其他目的，
则不需要实际将全局寄存器声明添加到它们的源代码中。只需指定编译器选项 -ffixed-reg 以保
留该寄存器。

全局寄存器变量不能有初始值，因为可执行文件没有办法为寄存器提供初始内容。选择寄存器时，选
择一个通常由被调函数保存和恢复的寄存器。这确保了不知情的代码（如库例程）在返回之前会恢复
它。在具有寄存器窗口的机器上，确保选择一个不受函数调用机制影响的全局寄存器。

当调用不知情的例程时，如果这些例程会回调回到调用它们的代码时，请谨慎处理。例如，如果你调
用系统库版本的 qsort，它可能会在执行期间破坏你的寄存器，但（如果你选择了适当的寄存器）
在返回之前会恢复它们。然而，在调用 qsort 的比较函数之前，它不会恢复这些寄存器。因此，除
非特别重新编译 qsort 函数，否则全局值在它的回调函数中将无法可靠地使用。

同样，从信号处理程序或多个控制线程中访问全局寄存器变量是不安全的。除非你为当前任务特别重
新编译它们，否则系统库例程可能会暂时将寄存器用于其他用途。此外，由于寄存器并未专门为变量
保留，从异步信号的处理程序访问它可能会观察到寄存器中存在不相关的临时值。

在大多数机器上，longjmp 会将每个全局寄存器变量恢复到 setjmp 时的值。然而，在某些机器
上，longjmp 不会更改全局寄存器变量的值。为了可移植性，调用 setjmp 的函数应采取其他措施
来保存全局寄存器变量的值，并在 longjmp 时恢复它们。这样，无论 longjmp 做了什么，都会发
有相同的结果。

**局部寄存器变量**

可以定义一个局部寄存器变量，并将其与指定的寄存器关联，如下所示： ::

    register int *foo asm ("r12");

这里 r12 是应该使用的寄存器名称。注意，这与定义全局寄存器变量的语法相同，但对于局部变
量，声明出现在函数内部。register 关键字是必需的，不能与 static 结合使用。寄存器名称必
须是目标平台的有效寄存器名称。不要使用类型限定符，如 const 和 volatile，因为结果可能与
预期相反。特别是，当使用 const 限定符时，编译器可能会在汇编语句中用初始化值替代变量，这
可能导致相应的操作数出现在不同的寄存器中。

与全局寄存器变量一样，建议选择一个有被调函数保存和恢复的寄存器，以便库例程的调用不会破坏
它。此功能的唯一支持用途是在调用扩展汇编时为输入输出操作数指定寄存器。如果特定机器的约束
没有提供足够的控制来选择所需的寄存器，则可能需要这样做。要强制操作数进入寄存器，创建一个
局部变量并在变量声明后指定寄存器名称。然后使用局部变量作为汇编操作数，并指定与寄存器匹配
的约束字母： ::

    register int *p1 asm ("r0") = ...;
    register int *p2 asm ("r1") = ...;
    register int *result asm ("r0");
    asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));

警告：在上面的示例中，请注意寄存器（例如 r0）可能会被后续代码，包括对其他变量的算术运算
的函数调用和库调用破坏。在这种情况下，请使用临时变量来处理寄存器赋值之间的表达式： ::

    int t1 = ...;
    register int *p1 asm ("r0") = ...;
    register int *p2 asm ("r1") = t1;
    register int *result asm ("r0");
    asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));

定义寄存器变量并不会保留该寄存器的值，除了调用扩展汇编时，寄存器中的内容不做保证。因此，
明确不支持以下用法。如果它们似乎有效，那也只是偶然，可能会因为周围代码看似无关的更改，或
未来版本 GCC 的微小变化而停止工作：传递参数给基本汇编或从基本汇编传出参数；从扩展汇编传
递参数，而不使用输入或输出操作数；从使用非标准调用约定的汇编（或其他语言）编写的例程传递
参数。

一些开发人员使用局部寄存器变量来尝试改善 GCC 的寄存器分配，特别是在大型函数中。在这种情
况下，寄存器名称基本上是对寄存器分配器的提示。虽然在某些情况下，这可以生成更好的代码，但
改进取决于分配器/优化器的任意性。由于没法保证你的改进不会丢失，因此不建议使用局部寄存器
变量。在 MIPS 平台上，局部寄存器变量的相关用法具有稍微不同的特性。

函数属性
---------

在 GNU C 和 C++ 中，你可以使用函数属性来指定某些函数特性，这些特性可能有助于编译器优化
调用或更仔细地检查代码的正确性。例如，你可以使用属性来指定一个函数永远不会返回
（noreturn）、返回值仅取决于其参数值（const），或者具有类似 printf 的参数（format）。
你还可以使用属性来控制内存放置、代码生成选项或说明函数内的调用/返回约定。许多这些属性是
特定于目标平台的。例如，许多目标平台支持定义中断处理函数的属性，这些函数通常必须遵循特殊
的寄存器使用和返回约定。这些属性在每个目标平台的子节中描述。然而，相当多的属性是大多数目
标平台都支持的，称为通用函数属性。

GCC 提供了两种不同的方式来指定属性：传统的 GNU 语法使用 __attribute__ ((...)) 注释，
以及更新的标准 C 和 C++ 语法使用带有 gnu:: 前缀属性名的 [[...]] 属性。请注意，根据你
使用的语法，属性在源代码中的放置规则有所不同。在同一个函数的不同声明上使用兼容的属性规范
会将它们合并。如果属性规范与已经应用于同一个函数声明的属性不兼容，则会发出警告并忽略该规
范。一些函数属性接受一个或多个参数，这些参数通过函数参数列表中的位置来引用函数的参数。这
样的属性参数被称为位置参数。除非另有说明，位置参数指定具有指针类型的参数的属性，也可以指
定非静态成员函数中 C++ this 参数以及指向指针类型的引用参数的属性。对于普通函数，位置 1
指的是列表中的第一个参数。在 C++ 非静态成员函数中，位置 1 指的是隐式的 this 指针。使用
普通函数或 C++ 成员函数的函数属性具有相同的限制和效果。

GCC 还支持变量属性、标签属性、枚举器属性、语句属性、类型属性，以及字段声明（用于
tainted_args）的属性。属性和 #pragma 指令（GCC 接受的指令）之间有一些重叠。使用
__attribute__ 被认为是将属性自然地附加到其对应的声明上的一种方便方式，而 #pragma 则用
于与其他编译器构造保持兼容。除了这里记录的属性外，GCC 插件可能提供自己的属性。

**alias ("target")** ::

    alias 属性声明当前符号是目标符号的别名，目标符号必须已经用相同的类型声明过，对于变
    量，还需要具有相同的大小和对齐方式。用与目标不同的类型声明别名是未定义的，并且可能
    会被诊断出来。 ::

    void __f () { /* Do something. */; }
    void f () __attribute__ ((weak, alias ("__f")));

    定义 f 是 __f 的弱别名。在 C++ 中，必须使用目标符号的最终修饰名。如果 __f 没有在
    同一个翻译单元中定义，则是错误的。此属性需要汇编器和目标文件支持，并且可能不是所有
    平台都支持。

X86属性
--------

在 x86 上，如果被调函数具有与调用者不同的 target 选项，内联器不会内联该函数，除非被调
用者具有调用者 target 选项的一个子集。例如，一个声明为 target("sse3") 的函数可以内联
一个具有target("sse2") 属性的函数，因为 -msse3 意味着 -msse2。除了基本规则外，当函数
指定 target("arch=ARCH") 或 target("tune=TUNE") 属性时，内联规则将有所不同。它允许
内联具有默认 -march=x86-64 和 -mtune=generic 的函数，或者具有 ISA 特性子集并标记为
always inline 的函数。

**cdecl** ::

    在 x86-32 目标平台上，cdecl 属性使编译器假设函数调用者会弹出用于传递参数的栈空间。
    这有助于覆盖 -mrtd 选项的效果。

**fastcall** ::

    在 x86-32 目标平台上，fastcall 属性使编译器将第一个参数（如果是整数类型）传递到寄
    存器 ECX 中，将第二个参数（如果是整数类型）传递到寄存器 EDX 中。后续的和其他类型的
    参数通过栈传递。被调函数会从栈中弹出参数。如果参数数量是可变的，所有参数都会被推送
    到栈上。

**thiscall** ::

    在 x86-32 目标平台上，thiscall 属性使编译器将第一个参数（如果是整数类型）传递到寄
    存器 ECX 中。后续的和其他类型的参数通过栈传递。被调函数会从栈中弹出参数。如果参数数
    量是可变的，所有参数都会被推送到栈上。thiscall 属性旨在用于 C++ 的非静态成员函数。
    作为 GCC 的扩展，这种调用约定也可以用于 C 函数和静态成员方法。

**naked** ::

    此属性允许编译器构造所需的函数声明，同时允许函数体为汇编代码。指定的函数不会生成由
    编译器生成的函数序言和尾声代码序列。只有基本的汇编语句可以安全地包含在裸函数中。虽
    然使用扩展汇编或将基本汇编与 C 代码混合看起来可以工作，但它们不能保证可靠地工作，并
    且不被支持。

**stdcall** ::

    在 x86-32 目标平台上，stdcall 属性使编译器假设被调函数会弹出用于传递参数的栈空间，
    除非它接受可变数量的参数。
