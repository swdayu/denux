GNU语言扩展
===========

GNU C 提供了一些在 ISO 标准 C 中不存在的语言特性。如果指定了 -pedantic 选项，GCC 会在
使用这些特性中的任何一个时打印警告消息。要测试这些特性在条件编译中的可用性，请检查预定义
的宏 __GNUC__，该宏在使用 GCC 时始终被定义。

这些扩展在 C 和 Objective-C 中可用。其中大多数在 C++ 中也可用。有关仅适用于 C++ 的扩
展，请参考 C++ 语言扩展部分。一些在 ISO C99 中存在但在 C90 或 C++ 中不存在的特性，作
为扩展，也被 GCC 扩充在 C90 模式和 C++ 中。

备用关键字
-----------

启用 -ansi 和各种 -std 选项会禁用某些关键字。如果你想要使用某些 GNU C 扩展或通用头文件
（该头文件要被所有程序使用，包括 ISO C 程序），可能会有麻烦。因为这种情况下，关键字
asm、typeof 和 inline 都不可用，除了 inline 可以在 c99 及之后的版本可用之外。另外
ISO C99 关键字 restrict 只有在使用 -std=gnu99、-std=c99 或更新标准时才可用。

解决这些问题的方法是在每个有问题的关键字的开头和结尾加上 __。例如，使用 __asm__ 代替
asm，使用 __inline__ 代替 inline。其他 C 编译器不接受这些备用关键字；如果你想用其他编
译器编译，你可以将备用关键字定义为宏，以替换为常用关键字，看起来像这样： ::

    #ifndef __GNUC__
    #define __asm__ asm
    #endif

选项 -pedantic 和其他选项会对许多 GNU C 扩展生成警告。你可以使用关键字 __extension__
来抑制这类警告。具体来说：在表达式之前写上 __extension__ 可以防止对该表达式内的扩展发
出警告；或者在早于 C23 标准的 C 代码中使用 [[__extension__ ...]] 可以抑制对使用形式
为 [[...]] 的属性的警告。__extension__ 除了上述用途外，没有其他作用。

内联汇编
---------

使用 asm 关键字允许你在 C 代码中嵌入汇编指令。GCC 提供了两种形式的内联汇编语句。基本汇
编语句没有扩展的 C 语言表达式操作数，而扩展的汇编语句包含一个或多个 C 语言表达式操作
数。在函数内混合 C 语言和汇编语言时，推荐使用扩展汇编，但如果要在顶级（即在函数外）包含
汇编语言，则必须使用基本汇编。你还可以使用 asm 关键字覆盖 C 语言符号的汇编名称，或者将
C 变量放置在特定的寄存器中。

**基本汇编**

基本汇编语句具有以下语法： ::

    asm asm-qualifiers ( AssemblerInstructions )

对于 C 语言，asm 关键字是一个 GNU 扩展。当编写能够使用 -ansi 选项和 -std 选项（选择一
个不含 GNU 扩展的 C 语言标准）进行编译的 C 语言代码时，请使用 __asm__ 代替 asm（参见
备用关键字部分）。对于 C++ 语言，asm 是一个标准关键字，但对于使用 -fno-asm 选项编译的
代码，可以使用 __asm__。

汇编限定符（qualifier）volatile：可选的 volatile 限定符没有任何作用，所有基本汇编块默
认都是 volatile 的。inline：如果你使用了 inline 限定符，那么为了内联，汇编语句的大小
总采用可能的最小大小，参见汇编语句的大小部分。

汇编语句的参数，汇编指令是一个指定汇编代码的字符串字面量。该字符串可以包含汇编器识别的任
何机器指令（instructions），包括汇编语法命令（directives）。GCC 不会解析汇编指令本
身，也不知道它们的含义，甚至不知道它们是否是有效的汇编输入。你可以将多个汇编指令放在一个
汇编字符串中，用系统汇编代码中通常用于分隔行的字符分隔。在大多数地方都适用的组合是使用一
个换行符用来分行，再加上一个制表符（写为 \n\t）。有些汇编器允许分号作为行分隔符，但是注
意有些汇编语言使用分号注释注释。

通常情况下，使用扩展汇编会产生更小、更安全、更高效的代码，在大多数情况下，它是一个比基本
汇编更好的解决方案。然而，有两种情况只能使用基本汇编：

1. 扩展的汇编语句必须在 C 函数内，因此要在顶级文件范围作用域，即在 C 函数之外编写内联汇
   编时，你必须使用基本汇编。你可以使用这种技术来生成汇编语法命令，定以在文件其他地方可
   以调用的汇编语言宏，或者使用汇编语言编写整个函数。函数外的基本汇编语句不能使用任何限
   定符。

2. 被声明为裸函数的函数也必须使用基本汇编，参见函数属性部分。

从基本汇编安全地访问 C 数据和调用函数比看起来要复杂得多。要访问 C 数据，最好使用扩展汇
编。不要期望一系列的汇编语句在编译后仍然完全连续。如果某些指令需要在输出中保持连续，将它
们集成放在包含多条指令的单个汇编语句中。注意，GCC 优化器可以相对其他代码移动汇编语句，
包括跨越跳转。汇编语句不能跳转到其他汇编语句中，GCC 不知道这些跳转，因此在决定如何优化
时无法考虑它们。跳转到 C 标签只在扩展汇编中受支持。

在某些情况下，GCC 可能在优化时对你的汇编代码进行复制（或删除重复项）。这可能会导致在编
译期间出现意外的重复符号错误，如果你的汇编代码定义了符号或标签。警告：C 标准并没有指定
asm 的语义，这使得它成为编译器之间潜在的不兼容性来源。这些不兼容性可能不会产生编译器警
告或错误。GCC 不会解析基本汇编的 AssemblerInstructions，这意味着没有办法向编译器传达
它们内部发生了什么。GCC 无法看到汇编中的符号，并且可能会将它们视为未引用的而丢弃。它也
不知道汇编代码的副作用，例如对内存或寄存器的修改。与某些编译器不同，GCC 假设不会对通用
寄存器进行更改。这一假设在未来版本中可能会改变。

为了避免未来对语义的更改带来的复杂性以及编译器之间的兼容性问题，请考虑用扩展汇编替换基本
汇编。有关如何进行此转换的信息，请参阅如何从基本汇编转换为扩展汇编
（https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended）。
编译器会将基本汇编中的汇编指令逐字复制到汇编语言输出文件中，而不会处理方言或扩展汇编中可
用的任何 % 操作符。这导致基本汇编字符串和扩展汇编模板之间存在细微差异。例如，引用寄存器
时，你可以在基本汇编中使用 %eax，而在扩展汇编中需要使用 %%eax。在支持多种汇编方言的目
标（如 x86）上，所有基本汇编块都使用由 -masm 命令行选项指定的汇编方言（默认为att语法风
格）。基本汇编没有机制为不同方言提供不同的汇编字符串。对于具有非空汇编字符串的基本汇编，
GCC 假设汇编块不会更改任何通用寄存器，但它可能会读取或写入任何全局可访问变量。
以下是一个适用于 i386 的基本汇编示例： ::

    // 注意，此代码无法与 -masm=intel 选项一起编译
    #define DebugBreak() asm("int $3")

**汇编语句的大小**

某些目标平台要求 GCC 跟踪每条指令的大小，以便生成正确的代码。由于汇编语句产生的代码的最
终长度只有汇编器才知道，GCC 必须估计它将有多大。它通过计算汇编语句中的指令数量，并将其
乘以该处理器支持的最长指令的长度来实现这一点。在计算指令数量时，它假设任何换行符或汇编器
支持的语句分隔符字符（通常是;）的出现表示一条指令的结束。

通常，GCC 的估计足以确保生成正确的代码，但如果你使用了伪指令或汇编宏，它们会扩展成多条
实际指令，或者如果你使用汇编语法指令，这些指令在目标文件中占用的空间比单条指令所需的空间
更多，那么就可能使编译器感到困惑。如果发生这种情况，汇编器可能会产生一个诊断信息，指出某
个标签无法到达。

这个大小也用于内联决策。如果你使用 asm inline 那么为了内联目的，汇编语句的大小将被视为
最小值，忽略 GCC 认为的大小。

控制汇编名称
------------

你可以使用 asm（或 __asm__）关键字来指定 C 函数或变量在汇编代码中的名称。你需要确保选
择的汇编名称不会与其他汇编符号或寄存器名称冲突。以下展示了如何为数据指定汇编名称： ::

    int foo asm ("myfoo") = 2;

它指定在汇编代码中变量 foo 的名称是 myfoo，而不是默认的 C 名称 _foo。GCC 不支持将此功
能用于非静态局部变量，因为这些变量没有汇编名称。如果你试图将变量放入特定寄存器，请参阅显
式寄存器变量部分。

要为函数指定汇编名称，需要在函数定义对函数进行声明，并加上 asm 语句，如下所示： ::

    int func (int x, int y) asm ("MYFUNC");
    int func (int x, int y)
    {
        /* . . . */
    }

这指定了在汇编代码中函数 func 的名称是 MYFUNC。

指定寄存器
----------

GNU C 允许你将特定的硬件寄存器与 C 变量关联。在几乎所有情况下，允许编译器分配寄存器会产
生最佳代码。然而，在某些不寻常的情况下，可能需要对变量存储进行更精确的控制。全局变量和局
部变量都可以与寄存器关联。执行此关联的后果在两者之间有很大不同，如下所述。

**全局寄存器变量**

你可以定义一个全局寄存器变量，并将其与指定的寄存器关联，如下所示： ::

    register int *foo asm ("r12");

这里 r12 是应该使用的寄存器名称。注意，这与定义局部寄存器变量的语法相同，但对于全局变
量，声明出现在函数外部。register 关键字是必需的，不能与 static 结合使用。寄存器名称必
须是目标平台的有效寄存器名称。不要使用类型限定符，如 const 和 volatile，因为结果可能与
预期相反。特别是，使用 volatile 限定符并不能完全防止编译器对寄存器的访问进行优化。

在大多数系统上，寄存器是一种稀缺资源，允许编译器对它们的使用进行管理通常会产生最佳代码。
然而，在特殊情况下，保留一些全局变量的寄存器是有意义的。例如，这在像编程语言解释器这样的
程序中可能会很有用，这些程序有几个经常访问的全局变量。

定义全局寄存器变量后，对于当前编译单元：

1. 如果寄存器是被调函数负责保护的寄存器，则调用 ABI 会受到影响：该寄存器变量被赋值后不
   会在函数尾声序列中恢复。因此，函数不能安全地返回给假设标准 ABI 的调用者。

2. 反之，如果寄存器是函数调用者保护的寄存器，则调用标准 ABI 函数可能会破坏变量的内容。
   即使在原始程序中没有这种调用，可能会被编译器创建，例如当使用 libgcc 函数来弥补不可
   用的指令时。

3. 对变量的访问可以像往常一样进行优化，寄存器仍然可以用于分配和计算，只要不影响变量的可
   观察值。

4. 如果在内联汇编中引用变量，则必须通过约束向编译器提供访问类型。不支持从基本汇编语句中
   对其进行访问。

注意，这些点仅当编译这些定义的代码时适用，仅链接的代码（例如来自库的代码）不受影响。如果
你想重新编译不实际使用你的全局寄存器变量的源文件，以便它们不将指定的寄存器用于其他目的，
则不需要实际将全局寄存器声明添加到它们的源代码中。只需指定编译器选项 -ffixed-reg 以保
留该寄存器。

全局寄存器变量不能有初始值，因为可执行文件没有办法为寄存器提供初始内容。选择寄存器时，选
择一个通常由被调函数保存和恢复的寄存器。这确保了不知情的代码（如库例程）在返回之前会恢复
它。在具有寄存器窗口的机器上，确保选择一个不受函数调用机制影响的全局寄存器。

当调用不知情的例程时，如果这些例程会回调回到调用它们的代码时，请谨慎处理。例如，如果你调
用系统库版本的 qsort，它可能会在执行期间破坏你的寄存器，但（如果你选择了适当的寄存器）
在返回之前会恢复它们。然而，在调用 qsort 的比较函数之前，它不会恢复这些寄存器。因此，除
非特别重新编译 qsort 函数，否则全局值在它的回调函数中将无法可靠地使用。

同样，从信号处理程序或多个控制线程中访问全局寄存器变量是不安全的。除非你为当前任务特别重
新编译它们，否则系统库例程可能会暂时将寄存器用于其他用途。此外，由于寄存器并未专门为变量
保留，从异步信号的处理程序访问它可能会观察到寄存器中存在不相关的临时值。

在大多数机器上，longjmp 会将每个全局寄存器变量恢复到 setjmp 时的值。然而，在某些机器
上，longjmp 不会更改全局寄存器变量的值。为了可移植性，调用 setjmp 的函数应采取其他措施
来保存全局寄存器变量的值，并在 longjmp 时恢复它们。这样，无论 longjmp 做了什么，都会发
有相同的结果。

**局部寄存器变量**

可以定义一个局部寄存器变量，并将其与指定的寄存器关联，如下所示： ::

    register int *foo asm ("r12");

这里 r12 是应该使用的寄存器名称。注意，这与定义全局寄存器变量的语法相同，但对于局部变
量，声明出现在函数内部。register 关键字是必需的，不能与 static 结合使用。寄存器名称必
须是目标平台的有效寄存器名称。不要使用类型限定符，如 const 和 volatile，因为结果可能与
预期相反。特别是，当使用 const 限定符时，编译器可能会在汇编语句中用初始化值替代变量，这
可能导致相应的操作数出现在不同的寄存器中。

与全局寄存器变量一样，建议选择一个有被调函数保存和恢复的寄存器，以便库例程的调用不会破坏
它。此功能的唯一支持用途是在调用扩展汇编时为输入输出操作数指定寄存器。如果特定机器的约束
没有提供足够的控制来选择所需的寄存器，则可能需要这样做。要强制操作数进入寄存器，创建一个
局部变量并在变量声明后指定寄存器名称。然后使用局部变量作为汇编操作数，并指定与寄存器匹配
的约束字母： ::

    register int *p1 asm ("r0") = ...;
    register int *p2 asm ("r1") = ...;
    register int *result asm ("r0");
    asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));

警告：在上面的示例中，请注意寄存器（例如 r0）可能会被后续代码，包括对其他变量的算术运算
的函数调用和库调用破坏。在这种情况下，请使用临时变量来处理寄存器赋值之间的表达式： ::

    int t1 = ...;
    register int *p1 asm ("r0") = ...;
    register int *p2 asm ("r1") = t1;
    register int *result asm ("r0");
    asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));

定义寄存器变量并不会保留该寄存器的值，除了调用扩展汇编时，寄存器中的内容不做保证。因此，
明确不支持以下用法。如果它们似乎有效，那也只是偶然，可能会因为周围代码看似无关的更改，或
未来版本 GCC 的微小变化而停止工作：传递参数给基本汇编或从基本汇编传出参数；从扩展汇编传
递参数，而不使用输入或输出操作数；从使用非标准调用约定的汇编（或其他语言）编写的例程传递
参数。

一些开发人员使用局部寄存器变量来尝试改善 GCC 的寄存器分配，特别是在大型函数中。在这种情
况下，寄存器名称基本上是对寄存器分配器的提示。虽然在某些情况下，这可以生成更好的代码，但
改进取决于分配器/优化器的任意性。由于没法保证你的改进不会丢失，因此不建议使用局部寄存器
变量。在 MIPS 平台上，局部寄存器变量的相关用法具有稍微不同的特性。

函数属性
---------

在 GNU C 和 C++ 中，你可以使用函数属性来指定某些函数特性，这些特性可能有助于编译器优化
调用或更仔细地检查代码的正确性。例如，你可以使用属性来指定一个函数永远不会返回
（noreturn）、返回值仅取决于其参数值（const），或者具有类似 printf 的参数（format）。
你还可以使用属性来控制内存放置、代码生成选项或说明函数内的调用/返回约定。许多这些属性是
特定于目标平台的。例如，许多目标平台支持定义中断处理函数的属性，这些函数通常必须遵循特殊
的寄存器使用和返回约定。这些属性在每个目标平台的子节中描述。然而，相当多的属性是大多数目
标平台都支持的，称为通用函数属性。

GCC 提供了两种不同的方式来指定属性：传统的 GNU 语法使用 __attribute__ ((...)) 注释，
以及更新的标准 C 和 C++ 语法使用带有 gnu:: 前缀属性名的 [[...]] 属性。请注意，根据你
使用的语法，属性在源代码中的放置规则有所不同。在同一个函数的不同声明上使用兼容的属性规范
会将它们合并。如果属性规范与已经应用于同一个函数声明的属性不兼容，则会发出警告并忽略该规
范。一些函数属性接受一个或多个参数，这些参数通过函数参数列表中的位置来引用函数的参数。这
样的属性参数被称为位置参数。除非另有说明，位置参数指定具有指针类型的参数的属性，也可以指
定非静态成员函数中 C++ this 参数以及指向指针类型的引用参数的属性。对于普通函数，位置 1
指的是列表中的第一个参数。在 C++ 非静态成员函数中，位置 1 指的是隐式的 this 指针。使用
普通函数或 C++ 成员函数的函数属性具有相同的限制和效果。

GCC 还支持变量属性、标签属性、枚举器属性、语句属性、类型属性，以及字段声明（用于
tainted_args）的属性。属性和 #pragma 指令（GCC 接受的指令）之间有一些重叠。使用
__attribute__ 被认为是将属性自然地附加到其对应的声明上的一种方便方式，而 #pragma 则用
于与其他编译器构造保持兼容。除了这里记录的属性外，GCC 插件可能提供自己的属性。

**alias ("target")** ::

    alias 属性声明当前符号是目标符号的别名，目标符号必须已经用相同的类型声明过，对于变
    量，还需要具有相同的大小和对齐方式。用与目标不同的类型声明别名是未定义的，并且可能
    会被诊断出来。 ::

    void __f () { /*Do something*/; }
    void f () __attribute__((weak, alias ("__f")));

    定义 f 是 __f 的弱别名。在 C++ 中，必须使用目标符号的最终修饰名。如果 __f 没有在
    同一个翻译单元中定义，则是错误的。此属性需要汇编器和目标文件支持，并且可能不是所有
    平台都支持。

X86属性
--------

在 x86 上，如果被调函数具有与调用者不同的 target 选项，内联器不会内联该函数，除非被调
用者具有调用者 target 选项的一个子集。例如，一个声明为 target("sse3") 的函数可以内联
一个具有target("sse2") 属性的函数，因为 -msse3 意味着 -msse2。除了基本规则外，当函数
指定 target("arch=ARCH") 或 target("tune=TUNE") 属性时，内联规则将有所不同。它允许
内联具有默认 -march=x86-64 和 -mtune=generic 的函数，或者具有 ISA 特性子集并标记为
always inline 的函数。

**cdecl** ::

    在 x86-32 目标平台上，cdecl 属性使编译器假设函数调用者会弹出用于传递参数的栈空间。
    这有助于覆盖 -mrtd 选项的效果。

**fastcall** ::

    在 x86-32 目标平台上，fastcall 属性使编译器将第一个参数（如果是整数类型）传递到寄
    存器 ECX 中，将第二个参数（如果是整数类型）传递到寄存器 EDX 中。后续的和其他类型的
    参数通过栈传递。被调函数会从栈中弹出参数。如果参数数量是可变的，所有参数都会被推送
    到栈上。

**thiscall** ::

    在 x86-32 目标平台上，thiscall 属性使编译器将第一个参数（如果是整数类型）传递到寄
    存器 ECX 中。后续的和其他类型的参数通过栈传递。被调函数会从栈中弹出参数。如果参数数
    量是可变的，所有参数都会被推送到栈上。thiscall 属性旨在用于 C++ 的非静态成员函数。
    作为 GCC 的扩展，这种调用约定也可以用于 C 函数和静态成员方法。

**naked** ::

    此属性允许编译器构造所需的函数声明，同时允许函数体为汇编代码。指定的函数不会生成由
    编译器生成的函数序言和尾声代码序列。只有基本的汇编语句可以安全地包含在裸函数中。虽
    然使用扩展汇编或将基本汇编与 C 代码混合看起来可以工作，但它们不能保证可靠地工作，并
    且不被支持。

**stdcall** ::

    在 x86-32 目标平台上，stdcall 属性使编译器假设被调函数会弹出用于传递参数的栈空间，
    除非它接受可变数量的参数。

属性语法
--------

GCC 提供了两种不同的方式来指定属性：标准 C 和 C++ 语法使用双方括号 [[...]]，以及较老的 
GNU 扩展语法使用 __attribute__ 关键字。__attribute__ 关键字在标准语法被采用之前就已
经存在，并且在旧代码中仍然广泛使用。标准的 [[...]] 属性语法可以被 GCC 的默认语言方言识
别。更具体地说，这种语法最初是在 C++11 语言标准中引入的，并且在使用 -std=c++11 或
-std=gnu++11 或更高版本编译 C++ 代码时被 GCC 支持。它也是 C23 语言标准的一部分，并且
在使用 -std=c23 或 -std=gnu17 或更高版本编译 C 代码时被支持。

当在标准语法中使用 GNU 特定的属性时，必须在它们的名称前加上 gnu::，例如gnu::section。
关于在代码中放置 [[...]] 属性的确切细节，请参考相关的语言标准，因为它们在某些细节上与
GNU 属性语法的规则有所不同。本节的其余部分描述了 GNU 扩展 __attribute__ 语法的细节，
以及属性说明符绑定的构造，针对 C 语言。对于 C++ 和 Objective-C，一些细节可能会有所不
同。由于属性语法的语法限制，这里描述的一些形式可能在所有情况下都无法成功解析。

在 C++ 中，属性的语义存在一些问题。例如，虽然属性可能会影响代码生成，但它们没有名称修
饰，因此在使用属性的类型与模板或重载结合使用时可能会出现问题。同样，typeid 无法区分具有
不同属性的类型。在未来，C++ 中对属性的支持可能会限制在仅对声明使用属性，而不是对嵌套声
明符使用属性。

属性说明符的形式为 __attribute__ ((attribute-list))。属性列表是一个可能为空的以逗号
分隔的属性序列，其中每个属性是以下形式之一：

* 空。空属性被忽略。

* 属性名称（可以是标识符如 unused，或者是保留字如 const）。

* 属性名称后跟一个括号内的属性参数列表。这些参数有以下几种形式：

  - 标识符。例如 mode 属性使用这种形式。
  - 标识符后跟一个逗号和一个非空的以逗号分隔的表达式列表。例如format属性使用这种形式。
  - 一个可能为空的以逗号分隔的表达式列表。例如 format_arg 属性使用这种形式，其列表是一
    个单一的整数常量表达式；alias 属性也使用这种形式，其列表是一个单一的字符串常量。

属性列表是一个或多个属性的序列，它们之间不使用任何其他标记分隔。你可以选择在属性名称前后
加上 __ 来指定属性名称。这允许你在头文件中使用它们，而不必担心可能有同名的宏。例如，你
可以使用属性名称 __noreturn__ 而不是 noreturn。

标签属性 ::

    GNU C 属性出现在冒号之后 label: __attribute__((name))
    GNU C++ 标签必须用分号结束 label:; __attribute__((name))

枚举器属性 ::

    enum {
        NAME __attribute__((name)) = 0,
    };

语句属性 ::

    switch (cond) {
    case 1:
        bar(1);
        __attribute__((fallthrough)); // 相当于空语句
    case 2:
        ...
    }

    int foo(int x, int y) {
        __attribute__((assume(x == 43)));
        return x + y;
    }

类型属性：struct union enum 之后，或者结束右大括号之后，前者更推荐。在右大括号之后出现
的属性被视为与所定义的结构体、联合体或枚举类型有关，所定义的类型直到属性之后才完整。 ::

    struct __attribute__((aligned (8))) type_t { short f[3]; };
    typedef struct type { short f[3]; } __attribute__((aligned (8))) type_t;

作为声明的一部分 ::

    int x __attribute__((aligned (16))) = 0;
    struct foo { int x[2] __attribute__((aligned (8))); };
    extern int old_var __attribute__ ((deprecated));
    int i __attribute__((visibility ("hidden")));

    typedef __attribute__((alloc_size (1))) void* (*malloc_ptr)(size_t);
    typedef int more_aligned_int __attribute__((aligned (8)));

    int var_target;
    extern int __attribute__((alias("var_target"))) var_alias;

    void __f() { ... }
    void f() __attribute__((weak, alias("__f")));

    __attribute__((access (read_only, 1))) int puts(const char*);
    void* my_memalign(size_t, size_t) __attribute__((alloc_align (1)));
    extern int p(void *, const char *, ...) __attribute__((format(printf,2,3)));

    void __attribute__((no_sanitize ("alignment,object-size"))) g() { ... }
    void __attribute__((visibility ("protected"))) f() { ... }

**其他属性**

此外，属性会作为声明的一部分出现，这里的声明包括未命名参数和类型名的声明，并且它与该声明
（该声明可能嵌套在另一个声明中，例如在参数声明的情况）或声明中的某个特定声明符相关。当属
性应用于被声明为函数或数组的参数时，它应该应用于该函数或数组，而不是应用于该参数隐式转换
后的指针，但目前这一点尚未正确实现。

声明开头的任何说明符和限定符列表都可以包含属性，无论在该上下文中这样的列表是否可以包含存
储类说明符。（不过，有些属性本质上具有存储类说明符的性质，并且只有在可以使用存储类说明符
的地方才有意义；例如 `section` 属性）这种语法有一个必要的限制：函数定义中的第一个旧式
参数声明不能以属性开头，因为按照下面描述的语法，这样的属性会应用到函数上（不过在这种情况
下该语法尚未实现）。在其他一些情况下，这种语法允许使用属性，但编译器尚未支持。此处的所有
属性都与整个声明相关。

在已过时的用法中，如果没有类型说明符则暗示类型为 `int`，这样的说明符和限定符列表可以仅
为一个属性列表，而不包含其他说明符或限定符。目前，函数原型中的第一个参数必须有某种非属性
的类型说明符；这解决了对 `void f(int (__attribute__((foo)) x))` 这种情况解释时的歧
义，但该规则可能会发生变化。目前，如果函数声明符的括号内仅包含属性，那么这些属性会被忽
略，而不会产生错误或警告，也不会暗示存在一个 `int` 类型的单一参数，但这种处理方式也可能
会改变。

在使用单一的说明符和限定符列表来声明多个标识符时，若声明中存在以逗号分隔的声明符列表，属
性列表可以紧跟在某个声明符（首个声明符除外）之前出现。此类属性仅适用于对应的标识符。例如
noreturn 属性适用于所有声明的函数，format 属性仅适用于 d1： ::

    __attribute__((noreturn)) void d0(void),
    __attribute__((format(printf, 1, 2))) d1(const char *, ...),
    d2 (void);

属性列表可以紧跟在标识符声明结束处的逗号、等号或分号之前出现。此类属性将应用于所声明的对
象或函数。当为对象或函数指定了汇编器名称时 ``int foo asm("myfoo") = 2;``，属性必须跟
在 asm 规范之后。未来，可能允许在函数定义的声明符之后（在任何旧式参数声明或函数体之前）
出现属性列表。

属性可以与出现在参数数组声明符 [] 内的类型限定符混合使用，在 C99 结构中，这些限定符会应
用于数组隐式转换后的指针。此类属性应用于指针，而非数组，但目前这一功能尚未实现，这些属性
会被忽略。

属性列表可以出现在嵌套声明符的开头。目前，这种用法存在一些限制：属性确实会正确应用于声明
符，但对于大多数单个属性，其所暗示的语义尚未实现。当属性跟在指针声明符的 * 之后时，它们
可以与现有的任何类型限定符混合使用。以下将描述这种语法的形式语义。如果您熟悉 ISO C 标准
中声明符的形式规范，那么理解起来会更有意义。

考虑（正如 C99 第 6.7.5 节第 4 段所述）声明 T D1，其中 T 包含指定类型 Type（如 int）
的声明说明符，而 D1 是一个包含标识符 ident 的声明符。对于类型不包含属性的派生声明符，
为 ident 指定的类型与 ISO C 标准中的规定一致。

如果 D1 的形式为 (属性列表 D)，并且声明 T D 为 ident 指定了类型 “派生声明符类型列表 
Type”，那么 T D1 为 ident 指定的类型则是 “派生声明符类型列表 属性列表 Type”。

如果 `D1` 具有 `* 类型限定符和属性列表 D` 的形式，并且声明 `T D` 为标识符 `ident` 指
定了 “派生声明符类型列表 Type” 类型，那么 `T D1` 为 `ident` 指定的类型是 “派生声明符类型列表 类型限定符和属性列表 指向 `Type` 的指针”。例如： ::

    void (__attribute__((noreturn)) ****f) (void);

此声明指定的类型是 “指向不返回的返回void的函数的指针的指针的指针的指针”。又如： ::

    char *__attribute__((aligned(8))) *f;

此声明指定的类型是 “指向8字节对齐的指向char类型的指针”。再次提醒，这对大多数属性并不适
用，例如上述对 aligned 和 noreturn 属性的使用目前还不被支持。

为了与为未实现嵌套声明符属性的编译器版本编写的现有代码兼容，在属性的放置上允许有一定的灵
活性。如果一个仅适用于类型的属性应用于某个声明，那么它会被视为应用于该声明的类型。如果一
个仅适用于声明的属性应用于某个声明的类型，那么它会被视为应用于该声明；并且，为了与将属性
直接放在被声明的标识符之前的代码兼容，应用于函数返回类型的此类属性会被视为应用于函数类
型，应用于数组元素类型的此类属性会被视为应用于数组类型。如果一个仅适用于函数类型的属性应
用于函数指针类型，那么它会被视为应用于指针所指向的目标类型；如果此类属性应用于非函数指针
类型的函数返回类型，那么它会被视为应用于函数类型。
